[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15968625&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is the branch of computer science that deals with the design, development, testing, and maintenance of software applications.
Software engineering has become increasingly significant in today’s digital age.

The extensive use of technology in various sectors, such as healthcare, finance, and transportation, has led to a growing demand for innovative and reliable software solutions.

From streaming services to video games, software engineers are at the forefront of creating immersive and interactive experiences for users worldwide, making software engineering important in many industries, including the entertainment industry.

The development of special effects, realistic graphics, and seamless user interfaces relies heavily on the expertise of software engineers.


Identify and describe at least three key milestones in the evolution of software engineering.

The History of Software Engineering
Around 1960, problem solving started becoming increasingly complicated. Additionally, existing methodologies had started showing their limitations. This resulted in huge losses, monetary and otherwise and companies were on the brink of shutting down. Eminent scientists and engineers gathered at the NATO Science Committee sponsored conference to resolve the “Software Crisis”. To optimise creating software without compromising on its quality, Software Engineering as a field was born.

Micro Computers & Workstations
Computing became public with Micro Computers. People no longer had to queue their code at the lab with a mainframe and wait for weeks to see its results. Companies started developing compilers for microcomputers and this was a huge leap for programming. Workstations like Alto could perform complex compilations. The demand for software increased, this, in turn, brought in new problems. Radical changes were critical to lower the chances of failure.

Object-Oriented Programming
With complex systems in place, results were no longer limited to numerical values. There were many simultaneous processes in action and finite state machines with simple inputs and outputs weren’t enough. OOP introduced imperative and procedural programming with “objects”. These objects could have specific types, different  and data fields could now be computed independently.
Internet
Yes, everything changed after the internet. Communities and forums evolved, connecting people around the world. The world’s best minds got together in real-time to resolve issues. It became possible to monitor databases and store them in the cloud. Over time, websites like Stack Overflow had answers to almost every question you could think of. The Internet changed everything.

End-User Development
This step was a full circle in terms of the journey of programming from labs to home. In 2005, Boehm predicted that by 2012 there would be more than 55 million end-user developers compared with fewer than 3 million professional programmers in the United States. Most people wouldn’t know that they have been a basic programmer if they’ve used a spreadsheet at some point or another. Low-code development platforms reduced the need to write code and brought new ways of approaching EUD.

Smart Devices and Cross-Platform Development Tools
A billion-dollar industry opened up when computers became mobile. A whole new field with its base in software engineering emerged. The global mobile application market size was valued at $106.27 billion in 2018 and projected to reach $407.31 billion by 2026, growing at a CAGR of 18.4% from 2019 to 2026 [1]. Many new platforms emerged and eventually tools that had cross-platform compatibility emerged. It became possible to run on multiple platforms.

Cloud Computing
Cloud computing enabled easy access to networks, applications, servers, services and storage. This fixed a lot of archaic concerns that were limiting software engineering. In theory, this gave us almost unlimited computing resources and everyone from corporations to governments started shifting operations to the cloud. Heavy demand also made this very cost-effective.
Artificial Intelligence
AI is helpful in all aspects of engineering, from design to deployment. Patterns are recognised, code is auto-generated, tested and then deployed. We are still in the early years but we have already achieved a lot of overall improvement. In time, we can expect more efficient, less time consuming, and extremely effective software development.

Quantum Computing
Quantum computing may never be able to take over classical computing, but we know that it is a game-changer. With time, we will see how this will change things but we know for sure that big changes are coming. There are many new SDKs that enable us to write and test quantum programming and almost everyone is getting in on this because of its predicted implications.

In conclusion, software engineering is just starting to mature. We have already seen major innovation and the best is yet to come. Very few imagined the extent to which this field has expanded to today and it will be the same for what’s to come.


List and briefly explain the phases of the Software Development Life Cycle.

Phase 1: Planning
The initial stage of software development, Planning, involves defining the software’s purpose and scope, much like pinpointing our destination and plotting the best route. We uncover the tasks at hand during this phase and strategize for efficient execution.

The team collaborates to understand the end-users’ needs and the goals the software should meet. Essentially, we ask, “What problem will this software solve?” and “What value will it offer to the user?”

A feasibility study also takes place during the Planning phase. Developers and product teams evaluate technical and financial challenges that might affect the software’s development or success.

So, what transpires in this phase? Key documents such as the Project Plan and Software Requirement Specification (SRS) are created. These guides detail the software’s functions, necessary resources, possible risks, and a project timeline.

The Planning phase fosters effective communication and collaboration within the team. By defining clear roles, responsibilities, and expectations, it lays a solid foundation for an efficient software development process.
Phase 2: Requirements Analysis
Phase 2 of the SDLC, Requirements Analysis, seeks to identify and record the precise requirements of the final users. In this Dr, the team is looking to answer, “What are the expectations of our users from our software?” This is called requirements gathering.

The project team collects information from stakeholders, including analysts, users, and clients. They conduct interviews, surveys, and focus groups to understand the user’s expectations and needs. The process involves not only asking the right questions but also accurately interpreting the responses.

After collecting the data, the team analyzes it, distinguishing the essential features from the desirable ones. This analysis helps the team understand the software’s functionality, performance, security, and interface needs.

These efforts result in a Requirements Specification Document. It outlines the software’s purpose, features, and functionalities, acting as a guide for the development team and providing cost estimates if needed. To ensure its reliability, the document is validated for accuracy, comprehensiveness, and feasibility.

The success of the Requirements Analysis phase is pivotal for the entire project. Done right, it leads to a software solution that meets users’ needs and exceeds their expectations.

Phase 3: Design
The Design phase is all about building the framework. The development team is responsible for software engineering and outlines the software’s functionality and aesthetic. This ultimately results in the software product. The emphasis lies on outlining the software’s structure, navigation, user interfaces, and database design. This phase ensures that the software is user-friendly and performs its tasks efficiently.

So, what tasks does the team undertake? Key activities include crafting data flow diagrams, constructing entity-relationship diagrams, and designing user interface mock-ups. The team also identifies system dependencies and integration points. They also set the software’s limitations, such as hardware constraints, performance requirements, and other system-related factors.

The culmination of these tasks is an exhaustive Software Design Document (SDD). This document serves as the roadmap for the team during the coding phase. It meticulously details the software’s design, from system architecture to data design, and even user interface specifics.

The Design phase Is the link between the software’s purpose (established in the Planning and Requirements Analysis phases) and its execution (defined in the coding phase). It’s an essential step in creating software that works efficiently and provides an excellent user experience
Phase 4: Coding
The Coding phase in the Software Development Life Cycle (SDLC) is when engineers and developers get down to business and start converting the software design into tangible code.

This development phase aims to develop software that is functional, efficient, and user-friendly. Developers use an appropriate programming language, Java or otherwise, to write the code, guided by the SDD and coding guidelines. This document, acting as a roadmap, ensures the software aligns with the vision set in earlier phases.

Another key aspect of this phase is regular code reviews. Team members carefully examine each other’s work to identify any bugs or inconsistencies. These meticulous assessments uphold high code standards, ensuring the software’s reliability and robustness. This phase also includes preliminary internal testing to confirm the software’s basic functionality.

At the end of this phase, a functional piece of software comes to life. It embodies the planning, analyzing, and designing efforts of the preceding stages. Though it may not be flawless, it represents a significant stride towards a valuable software solution.

Phase 5: Testing
Consider the Testing phase of the SDLC as a stringent quality inspection on a production line. It is when vulnerabilities are uncovered. Software testing involves a thorough examination of the software for any bugs or glitches that might have slipped through during coding. The aim is to ensure flawless software operation before it reaches the end-users. And even identify opportunities for enhancement.

The testing process begins by setting clear parameters in line with the software’s requirements. This includes identifying the necessary software conditions, and outlining diverse scenarios to examine these conditions. This step aids in creating an efficient testing strategy.

After establishing test cases, developers and engineers should rigorously test the software. They should conduct various types of tests, including unit testing, security testing, integration testing, system testing, and acceptance testing. These tests range from scrutinizing individual components to ensuring the seamless operation of the entire system.

When a test reveals a bug, it is documented in detail, noting its symptoms, reproduction method, and its influence on the software. These bugs are then sent back to the developers for rectification. Once the required fixes are implemented, the software re-enters the testing phase for validation. This process is a cycle of persistent refinement until the software complies with all predetermined parameters.

The Testing phase is instrumental in ensuring the software’s robustness and reliability

Phase 6: Deployment
After crafting a product with precision, it’s time to present it to the users by pushing to the production environment. The Deployment phase involves rolling out the meticulously tested and fine-tuned software to its end-users.

A specific strategy is executed for the software’s deployment to ensure minimal disruption to the user experience. Depending on the software and its audience, we might use different methods such as Big Bang, Blue-Green, or Canary deployments.

However, deployment isn’t just about launching the software. It’s about ensuring users can operate it with ease. This responsibility might involve creating user manuals, conducting training sessions, or offering on-site support. 

The Deployment phase doesn’t signal the end, but rather a notable milestone. It signifies the shift from a project phase to a product phase, where the software begins to fulfill its purpose.

Phase 7: Maintenance
In the Software Development Life Cycle, the maintenance phase is characterized by constant assistance and improvement, which guarantees the software’s best possible functioning and longevity and ensures it meets customer expectations.

The primary focus Is to adapt to the software’s changing needs. This adaptation involves responding to user feedback, resolving unexpected issues, and upgrading the software based on users’ evolving requirements. It’s a continuous process of refining and adapting, much like a gardener tending to their garden.

Maintenance tasks encompass frequent software updates, implementing patches, and fixing bugs. User support is also a crucial component, offering help and guidance to users facing difficulties with the software.

The maintenance phase also considers long-term strategies, for instance, upgrading or replacing the software. This decision depends on the software’s lifecycle and technological progress. Similar to a homeowner contemplating a renovation or selling their house, the software might require a complete revamp or phase-out to stay relevant and valuable.



Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

The main difference between Waterfall and Agile is:
Waterfall is a more traditional approach to project management, involving a linear flow.
Agile, on the other hand, embraces an iterative process. It involves rapid actions and great flexibility.
Tech startup developing a mobile app - Agile
Government software for public records - Waterfall
E-commerce website redesign - Agile
Construction of a new corporate office - Waterfall
Marketing campaign for a new product - Agile


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Software Developer
The developer is responsible for writing the code and developing the entire software product. Aside from coding, a software developer is responsible for sending updates to the project manager and working closely with other team members, including the designer and QA engineer. 
QA Engineer 
The QA or quality assurance engineer creates tests that identify issues with software before it is deployed. 

QA engineers monitor every phase of the software development process, including development, testing, debugging and delivery. They ensure that quality is maintained at every stage of the development process and that the final product meets the requirements.
Project Manager 
In software development, the roles of the project manager may include helping the team to design, execute, monitor and finish their work so that the clients will receive higher-quality software products. 



Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

What is an IDE?
An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently. It increases developer productivity by combining capabilities such as software editing, building, testing, and packaging in an easy-to-use application. Just as writers use text editors and accountants use spreadsheets, software developers use IDEs to make their job easier.
The Importance of Version Control Systems
Version control systems have become an integral part of software development workflows due to their ability to tackle several critical challenges faced by developers. By providing a centralized repository, these systems enable better code management, collaboration, and accountability. Let’s explore some key reasons why version control systems are of utmost importance:

Code Consistency: With version control systems, developers can maintain a consistent codebase. Every change made to the code is stored in the system, ensuring that the entire team is working on the same version. This eliminates the hassle of dealing with multiple copies and allows for efficient collaboration.
Collaboration: VCS significantly simplifies collaboration among developers. Multiple team members can work on the same project simultaneously, and any modifications are automatically synced with the central repository. This facilitates seamless teamwork and minimizes conflicts that arise from working on shared codebases.
Error Recovery: VCS provides a safety net for developers by offering the ability to revert to previous versions of the code. If a mistake is made or a bug is introduced, developers can easily roll back to a known working state. This saves valuable time and ensures that the project remains on track.
Record Keeping: Version control systems maintain a detailed history of changes made to the codebase. Each commit is documented, including the author, timestamp, and a description of the modifications. This audit trail is invaluable for understanding the evolution of the code and for identifying the root cause of issues.
Examples of version control system include Git, svb



What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Lack of Workflow Visibility
A lot of development teams suffer because of a vague understanding of the engineering processes within their organization. Many don’t have clarity about the status of the projects, the activities and challenges of the individuals, and whatnot. 
How to Combat Lack of Visibility in Development Teams? 
Invest in tools that empower your teams to make data-driven decisions: 

Project management tools
Engineering analytics tools
Observability & monitoring tools


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Level 1: Unit Testing
Unit testing is a fundamental software development strategy where individual code units (functions, methods, classes) are isolated and tested independently. This testing level focuses on verifying each unit’s internal logic and functionality to ensure they operate as expected.
Level 2: Integration Testing
Integration testing verifies how individual software components (modules) work together after being unit-tested. It focuses on ensuring individual software pieces. In this level of testing, two or more unit-tested modules are integrated to test technique-interacting components. Then, the results will show whether these modules perform as expected or not.
Level 3: System Testing
System testing is a comprehensive evaluation of a software system’s overall functionality and performance. It ensures that the entire system meets the development criteria. This level of testing is critical for detecting system-wide issues such as compatibility problems, performance bottlenecks, and security weaknesses.

Level 4: Acceptance Testing
Acceptance testing is the final stage of software testing, which ensures the software functions properly in the user’s working environment. It determines whether the software fits the business requirements and user acceptance criteria as expected or not. 

Unlike earlier testing levels, acceptance testing assesses the system from the user’s perspective, not the technical functionality.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the process of creating instructions for AI models to generate specific outputs. It involves providing context, examples, and instructions to help the model understand the user’s intent and respond in a meaningful way
Prompt engineering makes it easy for users to obtain relevant results in the first prompt. It helps mitigate bias that may be present from existing human bias in the large language models’ training data. Further, it enhances the user-AI interaction so the AI understands the user’s intention even with minimal input.



Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Researching a historical figure
Less Effective: “Tell me about that guy who invented the light bulb.”

More Effective: “Can you provide details on Thomas Edison’s invention of the light bulb?”

Explanation: While the first prompt might yield an answer about Thomas Edison, it leaves room for ambiguity. There were other inventors around the world who contributed to the development of the light bulb. The refined prompt specifies not only the person (Edison) but also narrows down the topic to Edison’s involvement with the light bulb. This specificity guides ChatGPT towards the exact information you’re seeking.


